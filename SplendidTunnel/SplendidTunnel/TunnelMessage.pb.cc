// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TunnelMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "TunnelMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace st {
class TunnelMessage_TunnelPacketDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TunnelMessage_TunnelPacket> {
} _TunnelMessage_TunnelPacket_default_instance_;
class TunnelMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TunnelMessage> {
} _TunnelMessage_default_instance_;

namespace protobuf_TunnelMessage_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[2];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[4];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage_TunnelPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage_TunnelPacket, packetdata_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, username_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, password_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, submask_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, gateway_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, dns_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, messagecode_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, passwordencrypttype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, linkencrypttype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TunnelMessage, packet_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(TunnelMessage_TunnelPacket)},
  { 6, -1, sizeof(TunnelMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_TunnelMessage_TunnelPacket_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_TunnelMessage_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "TunnelMessage.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 2);
}

}  // namespace

void TableStruct::Shutdown() {
  _TunnelMessage_TunnelPacket_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _TunnelMessage_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _TunnelMessage_TunnelPacket_default_instance_.DefaultConstruct();
  _TunnelMessage_default_instance_.DefaultConstruct();
  _TunnelMessage_default_instance_.get_mutable()->packet_ = const_cast< ::st::TunnelMessage_TunnelPacket*>(
      ::st::TunnelMessage_TunnelPacket::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\023TunnelMessage.proto\022\002st\"\320\004\n\rTunnelMess"
      "age\022\020\n\010username\030\001 \001(\t\022\020\n\010password\030\002 \001(\t\022"
      "\n\n\002ip\030\004 \001(\t\022\017\n\007submask\030\005 \001(\t\022\017\n\007gateway\030"
      "\006 \001(\t\022\013\n\003dns\030\007 \003(\t\022$\n\004type\030\010 \001(\0162\026.st.Tu"
      "nnelMessage.Type\0222\n\013messageCode\030\t \001(\0162\035."
      "st.TunnelMessage.MessageCode\022B\n\023password"
      "EncryptType\030\n \001(\0162%.st.TunnelMessage.Pas"
      "swordEncryptType\022:\n\017linkEncryptType\030\013 \001("
      "\0162!.st.TunnelMessage.LinkEncryptType\022.\n\006"
      "packet\030\r \001(\0132\036.st.TunnelMessage.TunnelPa"
      "cket\032\"\n\014TunnelPacket\022\022\n\npacketData\030\014 \001(\014"
      "\"!\n\004Type\022\013\n\007REQUEST\020\000\022\014\n\010RESPONSE\020\001\"C\n\013M"
      "essageCode\022\021\n\rAUTHORIZATION\020\000\022\r\n\tESTABLI"
      "SH\020\001\022\010\n\004BUSY\020\002\022\010\n\004DATA\020\003\")\n\023PasswordEncr"
      "yptType\022\006\n\002NO\020\000\022\n\n\006BASE64\020\001\"\037\n\017LinkEncry"
      "ptType\022\014\n\010RAW_DATA\020\000b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 628);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "TunnelMessage.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_TunnelMessage_2eproto

const ::google::protobuf::EnumDescriptor* TunnelMessage_Type_descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_enum_descriptors[0];
}
bool TunnelMessage_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TunnelMessage_Type TunnelMessage::REQUEST;
const TunnelMessage_Type TunnelMessage::RESPONSE;
const TunnelMessage_Type TunnelMessage::Type_MIN;
const TunnelMessage_Type TunnelMessage::Type_MAX;
const int TunnelMessage::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TunnelMessage_MessageCode_descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_enum_descriptors[1];
}
bool TunnelMessage_MessageCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TunnelMessage_MessageCode TunnelMessage::AUTHORIZATION;
const TunnelMessage_MessageCode TunnelMessage::ESTABLISH;
const TunnelMessage_MessageCode TunnelMessage::BUSY;
const TunnelMessage_MessageCode TunnelMessage::DATA;
const TunnelMessage_MessageCode TunnelMessage::MessageCode_MIN;
const TunnelMessage_MessageCode TunnelMessage::MessageCode_MAX;
const int TunnelMessage::MessageCode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TunnelMessage_PasswordEncryptType_descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_enum_descriptors[2];
}
bool TunnelMessage_PasswordEncryptType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TunnelMessage_PasswordEncryptType TunnelMessage::NO;
const TunnelMessage_PasswordEncryptType TunnelMessage::BASE64;
const TunnelMessage_PasswordEncryptType TunnelMessage::PasswordEncryptType_MIN;
const TunnelMessage_PasswordEncryptType TunnelMessage::PasswordEncryptType_MAX;
const int TunnelMessage::PasswordEncryptType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TunnelMessage_LinkEncryptType_descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_enum_descriptors[3];
}
bool TunnelMessage_LinkEncryptType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TunnelMessage_LinkEncryptType TunnelMessage::RAW_DATA;
const TunnelMessage_LinkEncryptType TunnelMessage::LinkEncryptType_MIN;
const TunnelMessage_LinkEncryptType TunnelMessage::LinkEncryptType_MAX;
const int TunnelMessage::LinkEncryptType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TunnelMessage_TunnelPacket::kPacketDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TunnelMessage_TunnelPacket::TunnelMessage_TunnelPacket()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_TunnelMessage_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:st.TunnelMessage.TunnelPacket)
}
TunnelMessage_TunnelPacket::TunnelMessage_TunnelPacket(const TunnelMessage_TunnelPacket& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  packetdata_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.packetdata().size() > 0) {
    packetdata_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.packetdata_);
  }
  // @@protoc_insertion_point(copy_constructor:st.TunnelMessage.TunnelPacket)
}

void TunnelMessage_TunnelPacket::SharedCtor() {
  packetdata_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

TunnelMessage_TunnelPacket::~TunnelMessage_TunnelPacket() {
  // @@protoc_insertion_point(destructor:st.TunnelMessage.TunnelPacket)
  SharedDtor();
}

void TunnelMessage_TunnelPacket::SharedDtor() {
  packetdata_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TunnelMessage_TunnelPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TunnelMessage_TunnelPacket::descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TunnelMessage_TunnelPacket& TunnelMessage_TunnelPacket::default_instance() {
  protobuf_TunnelMessage_2eproto::InitDefaults();
  return *internal_default_instance();
}

TunnelMessage_TunnelPacket* TunnelMessage_TunnelPacket::New(::google::protobuf::Arena* arena) const {
  TunnelMessage_TunnelPacket* n = new TunnelMessage_TunnelPacket;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TunnelMessage_TunnelPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:st.TunnelMessage.TunnelPacket)
  packetdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TunnelMessage_TunnelPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:st.TunnelMessage.TunnelPacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bytes packetData = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_packetdata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:st.TunnelMessage.TunnelPacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:st.TunnelMessage.TunnelPacket)
  return false;
#undef DO_
}

void TunnelMessage_TunnelPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:st.TunnelMessage.TunnelPacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes packetData = 12;
  if (this->packetdata().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      12, this->packetdata(), output);
  }

  // @@protoc_insertion_point(serialize_end:st.TunnelMessage.TunnelPacket)
}

::google::protobuf::uint8* TunnelMessage_TunnelPacket::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:st.TunnelMessage.TunnelPacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes packetData = 12;
  if (this->packetdata().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        12, this->packetdata(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:st.TunnelMessage.TunnelPacket)
  return target;
}

size_t TunnelMessage_TunnelPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:st.TunnelMessage.TunnelPacket)
  size_t total_size = 0;

  // bytes packetData = 12;
  if (this->packetdata().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->packetdata());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TunnelMessage_TunnelPacket::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:st.TunnelMessage.TunnelPacket)
  GOOGLE_DCHECK_NE(&from, this);
  const TunnelMessage_TunnelPacket* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TunnelMessage_TunnelPacket>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:st.TunnelMessage.TunnelPacket)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:st.TunnelMessage.TunnelPacket)
    MergeFrom(*source);
  }
}

void TunnelMessage_TunnelPacket::MergeFrom(const TunnelMessage_TunnelPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:st.TunnelMessage.TunnelPacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.packetdata().size() > 0) {

    packetdata_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.packetdata_);
  }
}

void TunnelMessage_TunnelPacket::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:st.TunnelMessage.TunnelPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TunnelMessage_TunnelPacket::CopyFrom(const TunnelMessage_TunnelPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:st.TunnelMessage.TunnelPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelMessage_TunnelPacket::IsInitialized() const {
  return true;
}

void TunnelMessage_TunnelPacket::Swap(TunnelMessage_TunnelPacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TunnelMessage_TunnelPacket::InternalSwap(TunnelMessage_TunnelPacket* other) {
  packetdata_.Swap(&other->packetdata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TunnelMessage_TunnelPacket::GetMetadata() const {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TunnelMessage_TunnelPacket

// bytes packetData = 12;
void TunnelMessage_TunnelPacket::clear_packetdata() {
  packetdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage_TunnelPacket::packetdata() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.TunnelPacket.packetData)
  return packetdata_.GetNoArena();
}
void TunnelMessage_TunnelPacket::set_packetdata(const ::std::string& value) {
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.TunnelPacket.packetData)
}
#if LANG_CXX11
void TunnelMessage_TunnelPacket::set_packetdata(::std::string&& value) {
  
  packetdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.TunnelPacket.packetData)
}
#endif
void TunnelMessage_TunnelPacket::set_packetdata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.TunnelPacket.packetData)
}
void TunnelMessage_TunnelPacket::set_packetdata(const void* value, size_t size) {
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.TunnelPacket.packetData)
}
::std::string* TunnelMessage_TunnelPacket::mutable_packetdata() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.TunnelPacket.packetData)
  return packetdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage_TunnelPacket::release_packetdata() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.TunnelPacket.packetData)
  
  return packetdata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage_TunnelPacket::set_allocated_packetdata(::std::string* packetdata) {
  if (packetdata != NULL) {
    
  } else {
    
  }
  packetdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packetdata);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.TunnelPacket.packetData)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TunnelMessage::kUsernameFieldNumber;
const int TunnelMessage::kPasswordFieldNumber;
const int TunnelMessage::kIpFieldNumber;
const int TunnelMessage::kSubmaskFieldNumber;
const int TunnelMessage::kGatewayFieldNumber;
const int TunnelMessage::kDnsFieldNumber;
const int TunnelMessage::kTypeFieldNumber;
const int TunnelMessage::kMessageCodeFieldNumber;
const int TunnelMessage::kPasswordEncryptTypeFieldNumber;
const int TunnelMessage::kLinkEncryptTypeFieldNumber;
const int TunnelMessage::kPacketFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TunnelMessage::TunnelMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_TunnelMessage_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:st.TunnelMessage)
}
TunnelMessage::TunnelMessage(const TunnelMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      dns_(from.dns_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.username().size() > 0) {
    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.password().size() > 0) {
    password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.ip().size() > 0) {
    ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
  }
  submask_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.submask().size() > 0) {
    submask_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.submask_);
  }
  gateway_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.gateway().size() > 0) {
    gateway_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gateway_);
  }
  if (from.has_packet()) {
    packet_ = new ::st::TunnelMessage_TunnelPacket(*from.packet_);
  } else {
    packet_ = NULL;
  }
  ::memcpy(&type_, &from.type_,
    reinterpret_cast<char*>(&linkencrypttype_) -
    reinterpret_cast<char*>(&type_) + sizeof(linkencrypttype_));
  // @@protoc_insertion_point(copy_constructor:st.TunnelMessage)
}

void TunnelMessage::SharedCtor() {
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  submask_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gateway_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&packet_, 0, reinterpret_cast<char*>(&linkencrypttype_) -
    reinterpret_cast<char*>(&packet_) + sizeof(linkencrypttype_));
  _cached_size_ = 0;
}

TunnelMessage::~TunnelMessage() {
  // @@protoc_insertion_point(destructor:st.TunnelMessage)
  SharedDtor();
}

void TunnelMessage::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  submask_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gateway_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete packet_;
  }
}

void TunnelMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TunnelMessage::descriptor() {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TunnelMessage& TunnelMessage::default_instance() {
  protobuf_TunnelMessage_2eproto::InitDefaults();
  return *internal_default_instance();
}

TunnelMessage* TunnelMessage::New(::google::protobuf::Arena* arena) const {
  TunnelMessage* n = new TunnelMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TunnelMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:st.TunnelMessage)
  dns_.Clear();
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  submask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && packet_ != NULL) {
    delete packet_;
  }
  packet_ = NULL;
  ::memset(&type_, 0, reinterpret_cast<char*>(&linkencrypttype_) -
    reinterpret_cast<char*>(&type_) + sizeof(linkencrypttype_));
}

bool TunnelMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:st.TunnelMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string username = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.username"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string password = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.password"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string ip = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.ip"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string submask = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_submask()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->submask().data(), this->submask().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.submask"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string gateway = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gateway()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->gateway().data(), this->gateway().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.gateway"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string dns = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_dns()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->dns(this->dns_size() - 1).data(),
            this->dns(this->dns_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "st.TunnelMessage.dns"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .st.TunnelMessage.Type type = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::st::TunnelMessage_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .st.TunnelMessage.MessageCode messageCode = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_messagecode(static_cast< ::st::TunnelMessage_MessageCode >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_passwordencrypttype(static_cast< ::st::TunnelMessage_PasswordEncryptType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_linkencrypttype(static_cast< ::st::TunnelMessage_LinkEncryptType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .st.TunnelMessage.TunnelPacket packet = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packet()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:st.TunnelMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:st.TunnelMessage)
  return false;
#undef DO_
}

void TunnelMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:st.TunnelMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string username = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.username");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->username(), output);
  }

  // string password = 2;
  if (this->password().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.password");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // string ip = 4;
  if (this->ip().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->ip(), output);
  }

  // string submask = 5;
  if (this->submask().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->submask().data(), this->submask().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.submask");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->submask(), output);
  }

  // string gateway = 6;
  if (this->gateway().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gateway().data(), this->gateway().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.gateway");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->gateway(), output);
  }

  // repeated string dns = 7;
  for (int i = 0, n = this->dns_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->dns(i).data(), this->dns(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.dns");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->dns(i), output);
  }

  // .st.TunnelMessage.Type type = 8;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->type(), output);
  }

  // .st.TunnelMessage.MessageCode messageCode = 9;
  if (this->messagecode() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->messagecode(), output);
  }

  // .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
  if (this->passwordencrypttype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->passwordencrypttype(), output);
  }

  // .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
  if (this->linkencrypttype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->linkencrypttype(), output);
  }

  // .st.TunnelMessage.TunnelPacket packet = 13;
  if (this->has_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->packet_, output);
  }

  // @@protoc_insertion_point(serialize_end:st.TunnelMessage)
}

::google::protobuf::uint8* TunnelMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:st.TunnelMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string username = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.username");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // string password = 2;
  if (this->password().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.password");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }

  // string ip = 4;
  if (this->ip().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->ip(), target);
  }

  // string submask = 5;
  if (this->submask().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->submask().data(), this->submask().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.submask");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->submask(), target);
  }

  // string gateway = 6;
  if (this->gateway().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gateway().data(), this->gateway().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.gateway");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->gateway(), target);
  }

  // repeated string dns = 7;
  for (int i = 0, n = this->dns_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->dns(i).data(), this->dns(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "st.TunnelMessage.dns");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(7, this->dns(i), target);
  }

  // .st.TunnelMessage.Type type = 8;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->type(), target);
  }

  // .st.TunnelMessage.MessageCode messageCode = 9;
  if (this->messagecode() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->messagecode(), target);
  }

  // .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
  if (this->passwordencrypttype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->passwordencrypttype(), target);
  }

  // .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
  if (this->linkencrypttype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->linkencrypttype(), target);
  }

  // .st.TunnelMessage.TunnelPacket packet = 13;
  if (this->has_packet()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->packet_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:st.TunnelMessage)
  return target;
}

size_t TunnelMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:st.TunnelMessage)
  size_t total_size = 0;

  // repeated string dns = 7;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->dns_size());
  for (int i = 0, n = this->dns_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->dns(i));
  }

  // string username = 1;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  // string password = 2;
  if (this->password().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());
  }

  // string ip = 4;
  if (this->ip().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip());
  }

  // string submask = 5;
  if (this->submask().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->submask());
  }

  // string gateway = 6;
  if (this->gateway().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gateway());
  }

  // .st.TunnelMessage.TunnelPacket packet = 13;
  if (this->has_packet()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->packet_);
  }

  // .st.TunnelMessage.Type type = 8;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // .st.TunnelMessage.MessageCode messageCode = 9;
  if (this->messagecode() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->messagecode());
  }

  // .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
  if (this->passwordencrypttype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->passwordencrypttype());
  }

  // .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
  if (this->linkencrypttype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->linkencrypttype());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TunnelMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:st.TunnelMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const TunnelMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TunnelMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:st.TunnelMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:st.TunnelMessage)
    MergeFrom(*source);
  }
}

void TunnelMessage::MergeFrom(const TunnelMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:st.TunnelMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dns_.MergeFrom(from.dns_);
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  if (from.password().size() > 0) {

    password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
  if (from.ip().size() > 0) {

    ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
  }
  if (from.submask().size() > 0) {

    submask_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.submask_);
  }
  if (from.gateway().size() > 0) {

    gateway_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gateway_);
  }
  if (from.has_packet()) {
    mutable_packet()->::st::TunnelMessage_TunnelPacket::MergeFrom(from.packet());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.messagecode() != 0) {
    set_messagecode(from.messagecode());
  }
  if (from.passwordencrypttype() != 0) {
    set_passwordencrypttype(from.passwordencrypttype());
  }
  if (from.linkencrypttype() != 0) {
    set_linkencrypttype(from.linkencrypttype());
  }
}

void TunnelMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:st.TunnelMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TunnelMessage::CopyFrom(const TunnelMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:st.TunnelMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelMessage::IsInitialized() const {
  return true;
}

void TunnelMessage::Swap(TunnelMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TunnelMessage::InternalSwap(TunnelMessage* other) {
  dns_.InternalSwap(&other->dns_);
  username_.Swap(&other->username_);
  password_.Swap(&other->password_);
  ip_.Swap(&other->ip_);
  submask_.Swap(&other->submask_);
  gateway_.Swap(&other->gateway_);
  std::swap(packet_, other->packet_);
  std::swap(type_, other->type_);
  std::swap(messagecode_, other->messagecode_);
  std::swap(passwordencrypttype_, other->passwordencrypttype_);
  std::swap(linkencrypttype_, other->linkencrypttype_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TunnelMessage::GetMetadata() const {
  protobuf_TunnelMessage_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_TunnelMessage_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TunnelMessage

// string username = 1;
void TunnelMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage::username() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.username)
  return username_.GetNoArena();
}
void TunnelMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.username)
}
#if LANG_CXX11
void TunnelMessage::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.username)
}
#endif
void TunnelMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.username)
}
void TunnelMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.username)
}
::std::string* TunnelMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage::release_username() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.username)
}

// string password = 2;
void TunnelMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage::password() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.password)
  return password_.GetNoArena();
}
void TunnelMessage::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.password)
}
#if LANG_CXX11
void TunnelMessage::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.password)
}
#endif
void TunnelMessage::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.password)
}
void TunnelMessage::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.password)
}
::std::string* TunnelMessage::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage::release_password() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.password)
}

// string ip = 4;
void TunnelMessage::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage::ip() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.ip)
  return ip_.GetNoArena();
}
void TunnelMessage::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.ip)
}
#if LANG_CXX11
void TunnelMessage::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.ip)
}
#endif
void TunnelMessage::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.ip)
}
void TunnelMessage::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.ip)
}
::std::string* TunnelMessage::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage::release_ip() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.ip)
}

// string submask = 5;
void TunnelMessage::clear_submask() {
  submask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage::submask() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.submask)
  return submask_.GetNoArena();
}
void TunnelMessage::set_submask(const ::std::string& value) {
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.submask)
}
#if LANG_CXX11
void TunnelMessage::set_submask(::std::string&& value) {
  
  submask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.submask)
}
#endif
void TunnelMessage::set_submask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.submask)
}
void TunnelMessage::set_submask(const char* value, size_t size) {
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.submask)
}
::std::string* TunnelMessage::mutable_submask() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.submask)
  return submask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage::release_submask() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.submask)
  
  return submask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage::set_allocated_submask(::std::string* submask) {
  if (submask != NULL) {
    
  } else {
    
  }
  submask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), submask);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.submask)
}

// string gateway = 6;
void TunnelMessage::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TunnelMessage::gateway() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.gateway)
  return gateway_.GetNoArena();
}
void TunnelMessage::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.gateway)
}
#if LANG_CXX11
void TunnelMessage::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.gateway)
}
#endif
void TunnelMessage::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.gateway)
}
void TunnelMessage::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.gateway)
}
::std::string* TunnelMessage::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TunnelMessage::release_gateway() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TunnelMessage::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.gateway)
}

// repeated string dns = 7;
int TunnelMessage::dns_size() const {
  return dns_.size();
}
void TunnelMessage::clear_dns() {
  dns_.Clear();
}
const ::std::string& TunnelMessage::dns(int index) const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.dns)
  return dns_.Get(index);
}
::std::string* TunnelMessage::mutable_dns(int index) {
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.dns)
  return dns_.Mutable(index);
}
void TunnelMessage::set_dns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:st.TunnelMessage.dns)
  dns_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void TunnelMessage::set_dns(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:st.TunnelMessage.dns)
  dns_.Mutable(index)->assign(std::move(value));
}
#endif
void TunnelMessage::set_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.dns)
}
void TunnelMessage::set_dns(int index, const char* value, size_t size) {
  dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.dns)
}
::std::string* TunnelMessage::add_dns() {
  // @@protoc_insertion_point(field_add_mutable:st.TunnelMessage.dns)
  return dns_.Add();
}
void TunnelMessage::add_dns(const ::std::string& value) {
  dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:st.TunnelMessage.dns)
}
#if LANG_CXX11
void TunnelMessage::add_dns(::std::string&& value) {
  dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:st.TunnelMessage.dns)
}
#endif
void TunnelMessage::add_dns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:st.TunnelMessage.dns)
}
void TunnelMessage::add_dns(const char* value, size_t size) {
  dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:st.TunnelMessage.dns)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
TunnelMessage::dns() const {
  // @@protoc_insertion_point(field_list:st.TunnelMessage.dns)
  return dns_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
TunnelMessage::mutable_dns() {
  // @@protoc_insertion_point(field_mutable_list:st.TunnelMessage.dns)
  return &dns_;
}

// .st.TunnelMessage.Type type = 8;
void TunnelMessage::clear_type() {
  type_ = 0;
}
::st::TunnelMessage_Type TunnelMessage::type() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.type)
  return static_cast< ::st::TunnelMessage_Type >(type_);
}
void TunnelMessage::set_type(::st::TunnelMessage_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.type)
}

// .st.TunnelMessage.MessageCode messageCode = 9;
void TunnelMessage::clear_messagecode() {
  messagecode_ = 0;
}
::st::TunnelMessage_MessageCode TunnelMessage::messagecode() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.messageCode)
  return static_cast< ::st::TunnelMessage_MessageCode >(messagecode_);
}
void TunnelMessage::set_messagecode(::st::TunnelMessage_MessageCode value) {
  
  messagecode_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.messageCode)
}

// .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
void TunnelMessage::clear_passwordencrypttype() {
  passwordencrypttype_ = 0;
}
::st::TunnelMessage_PasswordEncryptType TunnelMessage::passwordencrypttype() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.passwordEncryptType)
  return static_cast< ::st::TunnelMessage_PasswordEncryptType >(passwordencrypttype_);
}
void TunnelMessage::set_passwordencrypttype(::st::TunnelMessage_PasswordEncryptType value) {
  
  passwordencrypttype_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.passwordEncryptType)
}

// .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
void TunnelMessage::clear_linkencrypttype() {
  linkencrypttype_ = 0;
}
::st::TunnelMessage_LinkEncryptType TunnelMessage::linkencrypttype() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.linkEncryptType)
  return static_cast< ::st::TunnelMessage_LinkEncryptType >(linkencrypttype_);
}
void TunnelMessage::set_linkencrypttype(::st::TunnelMessage_LinkEncryptType value) {
  
  linkencrypttype_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.linkEncryptType)
}

// .st.TunnelMessage.TunnelPacket packet = 13;
bool TunnelMessage::has_packet() const {
  return this != internal_default_instance() && packet_ != NULL;
}
void TunnelMessage::clear_packet() {
  if (GetArenaNoVirtual() == NULL && packet_ != NULL) delete packet_;
  packet_ = NULL;
}
const ::st::TunnelMessage_TunnelPacket& TunnelMessage::packet() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.packet)
  return packet_ != NULL ? *packet_
                         : *::st::TunnelMessage_TunnelPacket::internal_default_instance();
}
::st::TunnelMessage_TunnelPacket* TunnelMessage::mutable_packet() {
  
  if (packet_ == NULL) {
    packet_ = new ::st::TunnelMessage_TunnelPacket;
  }
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.packet)
  return packet_;
}
::st::TunnelMessage_TunnelPacket* TunnelMessage::release_packet() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.packet)
  
  ::st::TunnelMessage_TunnelPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
void TunnelMessage::set_allocated_packet(::st::TunnelMessage_TunnelPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.packet)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace st

// @@protoc_insertion_point(global_scope)
