// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TunnelMessage.proto

#ifndef PROTOBUF_TunnelMessage_2eproto__INCLUDED
#define PROTOBUF_TunnelMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace st {
class TunnelMessage;
class TunnelMessageDefaultTypeInternal;
extern TunnelMessageDefaultTypeInternal _TunnelMessage_default_instance_;
class TunnelMessage_TunnelPacket;
class TunnelMessage_TunnelPacketDefaultTypeInternal;
extern TunnelMessage_TunnelPacketDefaultTypeInternal _TunnelMessage_TunnelPacket_default_instance_;
}  // namespace st

namespace st {

namespace protobuf_TunnelMessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_TunnelMessage_2eproto

enum TunnelMessage_Type {
  TunnelMessage_Type_REQUEST = 0,
  TunnelMessage_Type_RESPONSE = 1,
  TunnelMessage_Type_TunnelMessage_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TunnelMessage_Type_TunnelMessage_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TunnelMessage_Type_IsValid(int value);
const TunnelMessage_Type TunnelMessage_Type_Type_MIN = TunnelMessage_Type_REQUEST;
const TunnelMessage_Type TunnelMessage_Type_Type_MAX = TunnelMessage_Type_RESPONSE;
const int TunnelMessage_Type_Type_ARRAYSIZE = TunnelMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TunnelMessage_Type_descriptor();
inline const ::std::string& TunnelMessage_Type_Name(TunnelMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TunnelMessage_Type_descriptor(), value);
}
inline bool TunnelMessage_Type_Parse(
    const ::std::string& name, TunnelMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TunnelMessage_Type>(
    TunnelMessage_Type_descriptor(), name, value);
}
enum TunnelMessage_MessageCode {
  TunnelMessage_MessageCode_AUTHORIZATION = 0,
  TunnelMessage_MessageCode_ESTABLISH = 1,
  TunnelMessage_MessageCode_BUSY = 2,
  TunnelMessage_MessageCode_DATA = 3,
  TunnelMessage_MessageCode_TunnelMessage_MessageCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TunnelMessage_MessageCode_TunnelMessage_MessageCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TunnelMessage_MessageCode_IsValid(int value);
const TunnelMessage_MessageCode TunnelMessage_MessageCode_MessageCode_MIN = TunnelMessage_MessageCode_AUTHORIZATION;
const TunnelMessage_MessageCode TunnelMessage_MessageCode_MessageCode_MAX = TunnelMessage_MessageCode_DATA;
const int TunnelMessage_MessageCode_MessageCode_ARRAYSIZE = TunnelMessage_MessageCode_MessageCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TunnelMessage_MessageCode_descriptor();
inline const ::std::string& TunnelMessage_MessageCode_Name(TunnelMessage_MessageCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TunnelMessage_MessageCode_descriptor(), value);
}
inline bool TunnelMessage_MessageCode_Parse(
    const ::std::string& name, TunnelMessage_MessageCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TunnelMessage_MessageCode>(
    TunnelMessage_MessageCode_descriptor(), name, value);
}
enum TunnelMessage_PasswordEncryptType {
  TunnelMessage_PasswordEncryptType_NO = 0,
  TunnelMessage_PasswordEncryptType_BASE64 = 1,
  TunnelMessage_PasswordEncryptType_TunnelMessage_PasswordEncryptType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TunnelMessage_PasswordEncryptType_TunnelMessage_PasswordEncryptType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TunnelMessage_PasswordEncryptType_IsValid(int value);
const TunnelMessage_PasswordEncryptType TunnelMessage_PasswordEncryptType_PasswordEncryptType_MIN = TunnelMessage_PasswordEncryptType_NO;
const TunnelMessage_PasswordEncryptType TunnelMessage_PasswordEncryptType_PasswordEncryptType_MAX = TunnelMessage_PasswordEncryptType_BASE64;
const int TunnelMessage_PasswordEncryptType_PasswordEncryptType_ARRAYSIZE = TunnelMessage_PasswordEncryptType_PasswordEncryptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TunnelMessage_PasswordEncryptType_descriptor();
inline const ::std::string& TunnelMessage_PasswordEncryptType_Name(TunnelMessage_PasswordEncryptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TunnelMessage_PasswordEncryptType_descriptor(), value);
}
inline bool TunnelMessage_PasswordEncryptType_Parse(
    const ::std::string& name, TunnelMessage_PasswordEncryptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TunnelMessage_PasswordEncryptType>(
    TunnelMessage_PasswordEncryptType_descriptor(), name, value);
}
enum TunnelMessage_LinkEncryptType {
  TunnelMessage_LinkEncryptType_RAW_DATA = 0,
  TunnelMessage_LinkEncryptType_TunnelMessage_LinkEncryptType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TunnelMessage_LinkEncryptType_TunnelMessage_LinkEncryptType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TunnelMessage_LinkEncryptType_IsValid(int value);
const TunnelMessage_LinkEncryptType TunnelMessage_LinkEncryptType_LinkEncryptType_MIN = TunnelMessage_LinkEncryptType_RAW_DATA;
const TunnelMessage_LinkEncryptType TunnelMessage_LinkEncryptType_LinkEncryptType_MAX = TunnelMessage_LinkEncryptType_RAW_DATA;
const int TunnelMessage_LinkEncryptType_LinkEncryptType_ARRAYSIZE = TunnelMessage_LinkEncryptType_LinkEncryptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TunnelMessage_LinkEncryptType_descriptor();
inline const ::std::string& TunnelMessage_LinkEncryptType_Name(TunnelMessage_LinkEncryptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TunnelMessage_LinkEncryptType_descriptor(), value);
}
inline bool TunnelMessage_LinkEncryptType_Parse(
    const ::std::string& name, TunnelMessage_LinkEncryptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TunnelMessage_LinkEncryptType>(
    TunnelMessage_LinkEncryptType_descriptor(), name, value);
}
// ===================================================================

class TunnelMessage_TunnelPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:st.TunnelMessage.TunnelPacket) */ {
 public:
  TunnelMessage_TunnelPacket();
  virtual ~TunnelMessage_TunnelPacket();

  TunnelMessage_TunnelPacket(const TunnelMessage_TunnelPacket& from);

  inline TunnelMessage_TunnelPacket& operator=(const TunnelMessage_TunnelPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TunnelMessage_TunnelPacket& default_instance();

  static inline const TunnelMessage_TunnelPacket* internal_default_instance() {
    return reinterpret_cast<const TunnelMessage_TunnelPacket*>(
               &_TunnelMessage_TunnelPacket_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TunnelMessage_TunnelPacket* other);

  // implements Message ----------------------------------------------

  inline TunnelMessage_TunnelPacket* New() const PROTOBUF_FINAL { return New(NULL); }

  TunnelMessage_TunnelPacket* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TunnelMessage_TunnelPacket& from);
  void MergeFrom(const TunnelMessage_TunnelPacket& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TunnelMessage_TunnelPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes packetData = 12;
  void clear_packetdata();
  static const int kPacketDataFieldNumber = 12;
  const ::std::string& packetdata() const;
  void set_packetdata(const ::std::string& value);
  #if LANG_CXX11
  void set_packetdata(::std::string&& value);
  #endif
  void set_packetdata(const char* value);
  void set_packetdata(const void* value, size_t size);
  ::std::string* mutable_packetdata();
  ::std::string* release_packetdata();
  void set_allocated_packetdata(::std::string* packetdata);

  // @@protoc_insertion_point(class_scope:st.TunnelMessage.TunnelPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr packetdata_;
  mutable int _cached_size_;
  friend struct protobuf_TunnelMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TunnelMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:st.TunnelMessage) */ {
 public:
  TunnelMessage();
  virtual ~TunnelMessage();

  TunnelMessage(const TunnelMessage& from);

  inline TunnelMessage& operator=(const TunnelMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TunnelMessage& default_instance();

  static inline const TunnelMessage* internal_default_instance() {
    return reinterpret_cast<const TunnelMessage*>(
               &_TunnelMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TunnelMessage* other);

  // implements Message ----------------------------------------------

  inline TunnelMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  TunnelMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TunnelMessage& from);
  void MergeFrom(const TunnelMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TunnelMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TunnelMessage_TunnelPacket TunnelPacket;

  typedef TunnelMessage_Type Type;
  static const Type REQUEST =
    TunnelMessage_Type_REQUEST;
  static const Type RESPONSE =
    TunnelMessage_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return TunnelMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TunnelMessage_Type_Type_MIN;
  static const Type Type_MAX =
    TunnelMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TunnelMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TunnelMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TunnelMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TunnelMessage_Type_Parse(name, value);
  }

  typedef TunnelMessage_MessageCode MessageCode;
  static const MessageCode AUTHORIZATION =
    TunnelMessage_MessageCode_AUTHORIZATION;
  static const MessageCode ESTABLISH =
    TunnelMessage_MessageCode_ESTABLISH;
  static const MessageCode BUSY =
    TunnelMessage_MessageCode_BUSY;
  static const MessageCode DATA =
    TunnelMessage_MessageCode_DATA;
  static inline bool MessageCode_IsValid(int value) {
    return TunnelMessage_MessageCode_IsValid(value);
  }
  static const MessageCode MessageCode_MIN =
    TunnelMessage_MessageCode_MessageCode_MIN;
  static const MessageCode MessageCode_MAX =
    TunnelMessage_MessageCode_MessageCode_MAX;
  static const int MessageCode_ARRAYSIZE =
    TunnelMessage_MessageCode_MessageCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageCode_descriptor() {
    return TunnelMessage_MessageCode_descriptor();
  }
  static inline const ::std::string& MessageCode_Name(MessageCode value) {
    return TunnelMessage_MessageCode_Name(value);
  }
  static inline bool MessageCode_Parse(const ::std::string& name,
      MessageCode* value) {
    return TunnelMessage_MessageCode_Parse(name, value);
  }

  typedef TunnelMessage_PasswordEncryptType PasswordEncryptType;
  static const PasswordEncryptType NO =
    TunnelMessage_PasswordEncryptType_NO;
  static const PasswordEncryptType BASE64 =
    TunnelMessage_PasswordEncryptType_BASE64;
  static inline bool PasswordEncryptType_IsValid(int value) {
    return TunnelMessage_PasswordEncryptType_IsValid(value);
  }
  static const PasswordEncryptType PasswordEncryptType_MIN =
    TunnelMessage_PasswordEncryptType_PasswordEncryptType_MIN;
  static const PasswordEncryptType PasswordEncryptType_MAX =
    TunnelMessage_PasswordEncryptType_PasswordEncryptType_MAX;
  static const int PasswordEncryptType_ARRAYSIZE =
    TunnelMessage_PasswordEncryptType_PasswordEncryptType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PasswordEncryptType_descriptor() {
    return TunnelMessage_PasswordEncryptType_descriptor();
  }
  static inline const ::std::string& PasswordEncryptType_Name(PasswordEncryptType value) {
    return TunnelMessage_PasswordEncryptType_Name(value);
  }
  static inline bool PasswordEncryptType_Parse(const ::std::string& name,
      PasswordEncryptType* value) {
    return TunnelMessage_PasswordEncryptType_Parse(name, value);
  }

  typedef TunnelMessage_LinkEncryptType LinkEncryptType;
  static const LinkEncryptType RAW_DATA =
    TunnelMessage_LinkEncryptType_RAW_DATA;
  static inline bool LinkEncryptType_IsValid(int value) {
    return TunnelMessage_LinkEncryptType_IsValid(value);
  }
  static const LinkEncryptType LinkEncryptType_MIN =
    TunnelMessage_LinkEncryptType_LinkEncryptType_MIN;
  static const LinkEncryptType LinkEncryptType_MAX =
    TunnelMessage_LinkEncryptType_LinkEncryptType_MAX;
  static const int LinkEncryptType_ARRAYSIZE =
    TunnelMessage_LinkEncryptType_LinkEncryptType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LinkEncryptType_descriptor() {
    return TunnelMessage_LinkEncryptType_descriptor();
  }
  static inline const ::std::string& LinkEncryptType_Name(LinkEncryptType value) {
    return TunnelMessage_LinkEncryptType_Name(value);
  }
  static inline bool LinkEncryptType_Parse(const ::std::string& name,
      LinkEncryptType* value) {
    return TunnelMessage_LinkEncryptType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string dns = 7;
  int dns_size() const;
  void clear_dns();
  static const int kDnsFieldNumber = 7;
  const ::std::string& dns(int index) const;
  ::std::string* mutable_dns(int index);
  void set_dns(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns(int index, ::std::string&& value);
  #endif
  void set_dns(int index, const char* value);
  void set_dns(int index, const char* value, size_t size);
  ::std::string* add_dns();
  void add_dns(const ::std::string& value);
  #if LANG_CXX11
  void add_dns(::std::string&& value);
  #endif
  void add_dns(const char* value);
  void add_dns(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns();

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string ip = 4;
  void clear_ip();
  static const int kIpFieldNumber = 4;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string submask = 5;
  void clear_submask();
  static const int kSubmaskFieldNumber = 5;
  const ::std::string& submask() const;
  void set_submask(const ::std::string& value);
  #if LANG_CXX11
  void set_submask(::std::string&& value);
  #endif
  void set_submask(const char* value);
  void set_submask(const char* value, size_t size);
  ::std::string* mutable_submask();
  ::std::string* release_submask();
  void set_allocated_submask(::std::string* submask);

  // string gateway = 6;
  void clear_gateway();
  static const int kGatewayFieldNumber = 6;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // .st.TunnelMessage.TunnelPacket packet = 13;
  bool has_packet() const;
  void clear_packet();
  static const int kPacketFieldNumber = 13;
  const ::st::TunnelMessage_TunnelPacket& packet() const;
  ::st::TunnelMessage_TunnelPacket* mutable_packet();
  ::st::TunnelMessage_TunnelPacket* release_packet();
  void set_allocated_packet(::st::TunnelMessage_TunnelPacket* packet);

  // .st.TunnelMessage.Type type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::st::TunnelMessage_Type type() const;
  void set_type(::st::TunnelMessage_Type value);

  // .st.TunnelMessage.MessageCode messageCode = 9;
  void clear_messagecode();
  static const int kMessageCodeFieldNumber = 9;
  ::st::TunnelMessage_MessageCode messagecode() const;
  void set_messagecode(::st::TunnelMessage_MessageCode value);

  // .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
  void clear_passwordencrypttype();
  static const int kPasswordEncryptTypeFieldNumber = 10;
  ::st::TunnelMessage_PasswordEncryptType passwordencrypttype() const;
  void set_passwordencrypttype(::st::TunnelMessage_PasswordEncryptType value);

  // .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
  void clear_linkencrypttype();
  static const int kLinkEncryptTypeFieldNumber = 11;
  ::st::TunnelMessage_LinkEncryptType linkencrypttype() const;
  void set_linkencrypttype(::st::TunnelMessage_LinkEncryptType value);

  // @@protoc_insertion_point(class_scope:st.TunnelMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr submask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::st::TunnelMessage_TunnelPacket* packet_;
  int type_;
  int messagecode_;
  int passwordencrypttype_;
  int linkencrypttype_;
  mutable int _cached_size_;
  friend struct protobuf_TunnelMessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TunnelMessage_TunnelPacket

// bytes packetData = 12;
inline void TunnelMessage_TunnelPacket::clear_packetdata() {
  packetdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage_TunnelPacket::packetdata() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.TunnelPacket.packetData)
  return packetdata_.GetNoArena();
}
inline void TunnelMessage_TunnelPacket::set_packetdata(const ::std::string& value) {
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.TunnelPacket.packetData)
}
#if LANG_CXX11
inline void TunnelMessage_TunnelPacket::set_packetdata(::std::string&& value) {
  
  packetdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.TunnelPacket.packetData)
}
#endif
inline void TunnelMessage_TunnelPacket::set_packetdata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.TunnelPacket.packetData)
}
inline void TunnelMessage_TunnelPacket::set_packetdata(const void* value, size_t size) {
  
  packetdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.TunnelPacket.packetData)
}
inline ::std::string* TunnelMessage_TunnelPacket::mutable_packetdata() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.TunnelPacket.packetData)
  return packetdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage_TunnelPacket::release_packetdata() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.TunnelPacket.packetData)
  
  return packetdata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage_TunnelPacket::set_allocated_packetdata(::std::string* packetdata) {
  if (packetdata != NULL) {
    
  } else {
    
  }
  packetdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packetdata);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.TunnelPacket.packetData)
}

// -------------------------------------------------------------------

// TunnelMessage

// string username = 1;
inline void TunnelMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage::username() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.username)
  return username_.GetNoArena();
}
inline void TunnelMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.username)
}
#if LANG_CXX11
inline void TunnelMessage::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.username)
}
#endif
inline void TunnelMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.username)
}
inline void TunnelMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.username)
}
inline ::std::string* TunnelMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage::release_username() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.username)
}

// string password = 2;
inline void TunnelMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage::password() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.password)
  return password_.GetNoArena();
}
inline void TunnelMessage::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.password)
}
#if LANG_CXX11
inline void TunnelMessage::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.password)
}
#endif
inline void TunnelMessage::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.password)
}
inline void TunnelMessage::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.password)
}
inline ::std::string* TunnelMessage::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage::release_password() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.password)
}

// string ip = 4;
inline void TunnelMessage::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage::ip() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.ip)
  return ip_.GetNoArena();
}
inline void TunnelMessage::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.ip)
}
#if LANG_CXX11
inline void TunnelMessage::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.ip)
}
#endif
inline void TunnelMessage::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.ip)
}
inline void TunnelMessage::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.ip)
}
inline ::std::string* TunnelMessage::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage::release_ip() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.ip)
}

// string submask = 5;
inline void TunnelMessage::clear_submask() {
  submask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage::submask() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.submask)
  return submask_.GetNoArena();
}
inline void TunnelMessage::set_submask(const ::std::string& value) {
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.submask)
}
#if LANG_CXX11
inline void TunnelMessage::set_submask(::std::string&& value) {
  
  submask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.submask)
}
#endif
inline void TunnelMessage::set_submask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.submask)
}
inline void TunnelMessage::set_submask(const char* value, size_t size) {
  
  submask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.submask)
}
inline ::std::string* TunnelMessage::mutable_submask() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.submask)
  return submask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage::release_submask() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.submask)
  
  return submask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage::set_allocated_submask(::std::string* submask) {
  if (submask != NULL) {
    
  } else {
    
  }
  submask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), submask);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.submask)
}

// string gateway = 6;
inline void TunnelMessage::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TunnelMessage::gateway() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.gateway)
  return gateway_.GetNoArena();
}
inline void TunnelMessage::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:st.TunnelMessage.gateway)
}
#if LANG_CXX11
inline void TunnelMessage::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:st.TunnelMessage.gateway)
}
#endif
inline void TunnelMessage::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.gateway)
}
inline void TunnelMessage::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.gateway)
}
inline ::std::string* TunnelMessage::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TunnelMessage::release_gateway() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TunnelMessage::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.gateway)
}

// repeated string dns = 7;
inline int TunnelMessage::dns_size() const {
  return dns_.size();
}
inline void TunnelMessage::clear_dns() {
  dns_.Clear();
}
inline const ::std::string& TunnelMessage::dns(int index) const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.dns)
  return dns_.Get(index);
}
inline ::std::string* TunnelMessage::mutable_dns(int index) {
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.dns)
  return dns_.Mutable(index);
}
inline void TunnelMessage::set_dns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:st.TunnelMessage.dns)
  dns_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TunnelMessage::set_dns(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:st.TunnelMessage.dns)
  dns_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TunnelMessage::set_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:st.TunnelMessage.dns)
}
inline void TunnelMessage::set_dns(int index, const char* value, size_t size) {
  dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:st.TunnelMessage.dns)
}
inline ::std::string* TunnelMessage::add_dns() {
  // @@protoc_insertion_point(field_add_mutable:st.TunnelMessage.dns)
  return dns_.Add();
}
inline void TunnelMessage::add_dns(const ::std::string& value) {
  dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:st.TunnelMessage.dns)
}
#if LANG_CXX11
inline void TunnelMessage::add_dns(::std::string&& value) {
  dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:st.TunnelMessage.dns)
}
#endif
inline void TunnelMessage::add_dns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:st.TunnelMessage.dns)
}
inline void TunnelMessage::add_dns(const char* value, size_t size) {
  dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:st.TunnelMessage.dns)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TunnelMessage::dns() const {
  // @@protoc_insertion_point(field_list:st.TunnelMessage.dns)
  return dns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TunnelMessage::mutable_dns() {
  // @@protoc_insertion_point(field_mutable_list:st.TunnelMessage.dns)
  return &dns_;
}

// .st.TunnelMessage.Type type = 8;
inline void TunnelMessage::clear_type() {
  type_ = 0;
}
inline ::st::TunnelMessage_Type TunnelMessage::type() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.type)
  return static_cast< ::st::TunnelMessage_Type >(type_);
}
inline void TunnelMessage::set_type(::st::TunnelMessage_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.type)
}

// .st.TunnelMessage.MessageCode messageCode = 9;
inline void TunnelMessage::clear_messagecode() {
  messagecode_ = 0;
}
inline ::st::TunnelMessage_MessageCode TunnelMessage::messagecode() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.messageCode)
  return static_cast< ::st::TunnelMessage_MessageCode >(messagecode_);
}
inline void TunnelMessage::set_messagecode(::st::TunnelMessage_MessageCode value) {
  
  messagecode_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.messageCode)
}

// .st.TunnelMessage.PasswordEncryptType passwordEncryptType = 10;
inline void TunnelMessage::clear_passwordencrypttype() {
  passwordencrypttype_ = 0;
}
inline ::st::TunnelMessage_PasswordEncryptType TunnelMessage::passwordencrypttype() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.passwordEncryptType)
  return static_cast< ::st::TunnelMessage_PasswordEncryptType >(passwordencrypttype_);
}
inline void TunnelMessage::set_passwordencrypttype(::st::TunnelMessage_PasswordEncryptType value) {
  
  passwordencrypttype_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.passwordEncryptType)
}

// .st.TunnelMessage.LinkEncryptType linkEncryptType = 11;
inline void TunnelMessage::clear_linkencrypttype() {
  linkencrypttype_ = 0;
}
inline ::st::TunnelMessage_LinkEncryptType TunnelMessage::linkencrypttype() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.linkEncryptType)
  return static_cast< ::st::TunnelMessage_LinkEncryptType >(linkencrypttype_);
}
inline void TunnelMessage::set_linkencrypttype(::st::TunnelMessage_LinkEncryptType value) {
  
  linkencrypttype_ = value;
  // @@protoc_insertion_point(field_set:st.TunnelMessage.linkEncryptType)
}

// .st.TunnelMessage.TunnelPacket packet = 13;
inline bool TunnelMessage::has_packet() const {
  return this != internal_default_instance() && packet_ != NULL;
}
inline void TunnelMessage::clear_packet() {
  if (GetArenaNoVirtual() == NULL && packet_ != NULL) delete packet_;
  packet_ = NULL;
}
inline const ::st::TunnelMessage_TunnelPacket& TunnelMessage::packet() const {
  // @@protoc_insertion_point(field_get:st.TunnelMessage.packet)
  return packet_ != NULL ? *packet_
                         : *::st::TunnelMessage_TunnelPacket::internal_default_instance();
}
inline ::st::TunnelMessage_TunnelPacket* TunnelMessage::mutable_packet() {
  
  if (packet_ == NULL) {
    packet_ = new ::st::TunnelMessage_TunnelPacket;
  }
  // @@protoc_insertion_point(field_mutable:st.TunnelMessage.packet)
  return packet_;
}
inline ::st::TunnelMessage_TunnelPacket* TunnelMessage::release_packet() {
  // @@protoc_insertion_point(field_release:st.TunnelMessage.packet)
  
  ::st::TunnelMessage_TunnelPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void TunnelMessage::set_allocated_packet(::st::TunnelMessage_TunnelPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:st.TunnelMessage.packet)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace st

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::st::TunnelMessage_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::st::TunnelMessage_Type>() {
  return ::st::TunnelMessage_Type_descriptor();
}
template <> struct is_proto_enum< ::st::TunnelMessage_MessageCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::st::TunnelMessage_MessageCode>() {
  return ::st::TunnelMessage_MessageCode_descriptor();
}
template <> struct is_proto_enum< ::st::TunnelMessage_PasswordEncryptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::st::TunnelMessage_PasswordEncryptType>() {
  return ::st::TunnelMessage_PasswordEncryptType_descriptor();
}
template <> struct is_proto_enum< ::st::TunnelMessage_LinkEncryptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::st::TunnelMessage_LinkEncryptType>() {
  return ::st::TunnelMessage_LinkEncryptType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TunnelMessage_2eproto__INCLUDED
